'use strict';

/**
 * Classes used to bind custom methods to
 * request and response objects.
 */
const Request     = require('./request.js');
const Response    = require('./response.js');

const Helpers     = require('./helpers.js');

/**
 * Router Routes being registered by Coyote
 * class.
 * @type {{}}
 */
const Routes      = {};
const Cache       = {};

/**
 * Router Middlewares Entity
 * @type {{globals: Array}}
 */
const Middlewares = { globals: [] };

class Router
{
    /**
     * Bind the custom methods and search
     * the route.
     * @param req
     * @param res
     */
    static dispatch(req, res)
    {
        Router.req = Request.bind(req);
        Router.res = Response.bind(res);
        Router.parse();
    }

    /**
     * Parse the url and handle the response
     * @param url
     */
    static parse()
    {
        Router.method   = Router.req.method().toLowerCase();
        Router.url      = Router.req.url;

        if ( !Helpers.has(Routes, Router.url)
             || !Helpers.has(Routes[Router.url], Router.method) )
        {
            if ( Helpers.has(Routes, '*')  )
            {
                if ( Helpers.has(Routes['*'], Router.method) )
                {
                    Router.route = Routes['*'][Router.method];
                }

                if ( Helpers.has(Routes['*'], '*') )
                {
                    Router.route = Routes['*']['*'];
                }
            }
            else
            {
                /**
                 * We have no direct route access, possibly a dynamic route?
                 */
                let parsed = Router.url.split('/');
                let found  = false;

                Helpers.forOwn(Cache, (method, route) => {
                    /**
                     * Check if the route allows dynamic content
                     */
                    if ( /\:\w+/gi.test(route) )
                    {
                        let possible = route.split('/');
                        let valid    = false;

                        Helpers.forOwn(parsed, (actual) => {
                            Helpers.forOwn(possible, (probably) => {
                                if ( actual === probably )
                                {
                                    valid = true;
                                }
                            });
                        });

                        if ( valid )
                        {
                            Router.route = Routes[route][method];
                            found        = true;
                        }
                    }
                });

                if ( found )
                {
                    Router.middlewares().then(() => {
                        Router.route.handle(Router.req, Router.res);
                    });

                    return;
                }

                Router.res.end(`Could not ${Router.method} to ${Router.url}.`);
                return;
            }
        }

        /**
         * Method priority
         */
        if ( Helpers.has(Routes[Router.url], Router.method) )
        {
            Router.route = Routes[Router.url][Router.method];
        }

        if ( Helpers.has(Routes[Router.url], '*') )
        {
            Router.route = Routes[Router.url]['*'];
        }

        Router.middlewares().then(() => {
            Router.route.handle(Router.req, Router.res);
        });
    }

    /**
     * Checks and runs for middlewares before running the
     * actual function. Note these are being run in series.
     * @returns {Promise}
     */
    static middlewares()
    {
        return new Promise((resolve, reject) => {
            /**
             * Get all the middlewares a route should run,
             * and remember to cache them :D
             */

            let middlewares = [];

            /**
             * Global middlewares
             */
            middlewares = middlewares.concat(Middlewares.globals);

            /**
             * Route specific middlewares
             */
            middlewares = middlewares.concat(Router.route.middlewares);

            /**
             * We got no middlewares, let's just run
             * the handler.
             */
            if ( !middlewares.length )
            {
                resolve();
                return;
            }

            /**
             * Run the middlewares in series
             */

            let done  = 0;
            let total = middlewares.length;

            function runMiddlewares() {
                let middleware = middlewares[done];

                if ( done === total )
                {
                    resolve();
                    return;
                }

                done++;

                middleware(Router.req, Router.res, (failed) => {
                    if ( typeof failed !== 'undefined' )
                    {
                        return;
                    }

                    if ( !failed && typeof middleware !== 'undefined' )
                    {
                        runMiddlewares();
                        return;
                    }
                });
            }

            runMiddlewares();
        });
    }

    /**
     * Register an entity to Coyote's handlers
     * @param type
     * @param payload
     */
    static register(type, payload)
    {
        if ( type === 'route' )
        {
            let argc    = payload.length;
            let route   = payload[0];
            let method  = payload[1];
            let handler = payload[argc - 1];

            if ( !Helpers.has(Routes, route) )
            {
                Routes[route]         = {};
                Routes[route][method] = {};
            }

            Routes[route][method].handle      = handler;
            Routes[route][method].middlewares = [];

            /**
             * Push the route to cache for faster dynamic
             * route finding
             */
            Cache[route] = method;

            /**
             * Register other additional functions as
             * middlewares for the route
             */
            if ( argc > 3 )
            {
                let middlewares = payload.splice(2, argc - 3);

                Helpers.forOwn(middlewares, (m) => {
                    Routes[route][method].middlewares.push(m);
                });
            }
        }

        if ( type === 'middleware' )
        {
            let argc    = payload.length;
            let route   = argc > 1 ? argc[0] : false;
            let method  = argc > 2 ? argc[1] : false;
            let handler = payload[argc - 1];

            if ( !route && !method )
            {
                Middlewares.globals.push(handler);
                return;
            }

            if ( route && !method )
            {
                if ( !Helpers.has(Middlewares, route) )
                {
                    Middlewares[route] = {};
                }

                if ( !Helpers.has(Middlewares, '*') )
                {
                    Middlewares[route]['*'] = [];
                }

                Middlewares[route]['*'].push(handler);
                return;
            }
        }
    }
}

module.exports = Router;